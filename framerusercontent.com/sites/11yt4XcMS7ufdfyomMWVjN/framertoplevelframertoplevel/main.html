 import * as React from "react" import * as ReactDOM from "react-dom/client" import * as Framer from "framer" const routes = {augiA20Il: {elements: {A7HVQ2sEn: "projects", FzEaqlbzf: "cta", lyjAR2wG7: "testimonials", ncW996027: "about", oFpHwf5bL: "footer",
oJZkUB_s5: "faq", qqyRYr0yf: "secondary-cta", rMTHiwicD: "services", xuDGdU47e: "teaser", ZtLSsUNQJ: "hero"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/dhgalFYabClBeLeLhNto/tTnWVD4Gg1v6wYXbaOC2/augiA20Il.js")), path: "/"},
LqvzCkTjw: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/qnakARXTJCNRt1vOXx06/CoazdAc5x7lS78QXHZiV/LqvzCkTjw.js")), path: "/style-guide"}, aRFsYYpX7: {collectionId: "HZupMaHf5", elements: {C4soDZ0ra: "project-detail"},
page: Framer.lazy(() => import("https://framerusercontent.com/modules/1e1zfkc51k30wyzDg06r/8YcbFSP52zmDjOo7WCZ9/aRFsYYpX7.js")), path: "/projects/:sqBriXHle"}, wvmAhX_vx: {page: Framer.lazy(() => import("https://framerusercontent.com/modules/3PtmPruWldLCkoLskVFv/lfNruPl7Zu64cj9Wc28V/wvmAhX_vx.js"))}}
const locales = [{code: "en", id: "default", name: "English", slug: ""}] export async function getPageRoot({ routeId, pathVariables, localeId }) { // We don't want the initial render to immediately have to suspend. await routes[routeId].page.preload()
const content = React.createElement( Framer.PageRoot, { isWebsite: true, routeId, pathVariables, routes, collectionUtils: {HZupMaHf5: async () => (await import("https://framerusercontent.com/modules/oVkIwVqhSoT6YT3jHJp6/K8AxdxjIrUwkDwZ0fgVG/HZupMaHf5.js"))?.["utils"]},
framerSiteId: "8cdaa4919e4bffeef7bb04030ff3819bef568288ac4e2e3392d7e8a2b8b36a33", notFoundPage: Framer.lazy(() => import("__framer-not-found-page")), isReducedMotion: undefined, localeId, locales, preserveQueryParams: undefined, } ) const contentWithFeaturesContext
= React.createElement( Framer.LibraryFeaturesProvider, { children: content, value: {enableAsyncURLUpdates: true, replaceNestedLinks: true, useGranularSuspense: true, wrapUpdatesInTransitions: false} } ) const page = React.createElement(Framer.PageEffectsProvider,
{ children: contentWithFeaturesContext, value: {global: {enter: {opacity: 0, rotate: 0, rotate3d: false, rotateX: 0, rotateY: 0, scale: 1, transition: {damping: 30, delay: 0, duration: 0.2, ease: [0.27, 0, 0.51, 1], mass: 1, stiffness: 400, type: "tween"},
x: "0px", y: "0px"}}, routes: {}} }) return page } const isBrowser = typeof document !== "undefined" if (isBrowser) { window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => () => { return React.createElement(Framer.ErrorPlaceholder,
{ error: 'Package component not supported: "' + exportIdentifier + '" in "' + packageAndFilename + '"' }) } // A lot of libraries assume process.env.NODE_ENV is present in runtime/buildtime, so we are polyfilling it window.process = { ...window.process,
env: { ...(window.process ? window.process.env: undefined), NODE_ENV: "production" } } window.__framer_events = window.__framer_events || [] // Fallback support for stack gaps Framer.installFlexboxGapWorkaroundIfNeeded() const container = document.getElementById("main")
// We know that #main is parsed before this script, so we don't need to wait for DOMContentLoaded or similar events. if ("framerHydrateV2" in container.dataset) main(true, container) else main(false, container) } function track() { if (!isBrowser) return
window.__framer_events.push(arguments) } async function main(shouldHydrate, container) { try { let routeId, localeId, pathVariables, breakpoints if (shouldHydrate) { const routeData = JSON.parse(container.dataset.framerHydrateV2) routeId = routeData.routeId
localeId = routeData.localeId pathVariables = routeData.pathVariables breakpoints = routeData.breakpoints } else { const routeData = Framer.inferInitialRouteFromPath(routes, decodeURIComponent(location.pathname), true, locales) routeId = routeData.routeId
localeId = routeData.localeId pathVariables = routeData.pathVariables } const page = await getPageRoot({ routeId, localeId, pathVariables }) function handleRecoverableError(error, errorInfo) { const componentStack = errorInfo?.componentStack console.warn("Recoverable
error during hydration. Please check any custom code or code overrides to fix server/client mismatches.", error, componentStack) // we only want to collect 1%, because this can be quite noisy (floods the data pipeline) if (Math.random() > 0.01) return
track("published_site_load_recoverable_error", { message: String(error), componentStack, // componentStack is more useful stack: componentStack ? undefined : error instanceof Error && typeof error.stack === "string" ? error.stack : null, }) } if (shouldHydrate)
{ Framer.withPerformanceMarks("framer-rewrite-breakpoints", () => { Framer.removeHiddenBreakpointLayersV2(breakpoints) window.__framer_onRewriteBreakpoints?.(breakpoints) }) const startTransition = React.startTransition startTransition(() => { Framer.markHydrationStart()
Framer.setInitialHydrationState() if (true) Framer.turnOffReactEventHandling() ReactDOM.hydrateRoot(container, page, { onRecoverableError: handleRecoverableError }) }) } else { ReactDOM.createRoot(container, { onRecoverableError: handleRecoverableError
}).render(page) } } catch (error) { track("published_site_load_error", { message: String(error), stack: error instanceof Error && typeof error.stack === "string" ? error.stack : null }) throw error } }